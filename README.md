# Skylords Rebot

This is a bot written for the game [Skylords Reborn](https://skylords.eu), a community revival project of the game *Battleforge*, which was initially developed by EA.

Battleforge is a RTS game with TCG elements as players build a deck of cards before each match which consists of units, spells and buildings than can be played. It has a PvE campaign as well as a 1v1 and 2v2 PvP mode.

There are only two types of resources in the game:
1. Power, which is generated by *Power Wells* and
2. Orbs, which are created by *Monuments* and let the player use higher-level cards

Cards always have a Power cost which must be paid and orb restrictions which must be fullfilled, similar to Magic the Gathering and their use of lands.

## Power Economy

To understand how PvP is played in Battleforge a brief overview of the power economy is required.

There are three types of power in the game:
1. **Free Power**: This is the power that is available to the player and free to be spent on units, spells or buildings. It is increased through built Power Wells and *Void Power*.
2. **Bound Power**: The power which is spent on a unit or building. E.g. the player uses 50 of its available power to spawn a unit, which is then binding this 50 power.
3. **Void Power**: A unique mechanic to Battleforge this is another pool of power which is filled through releasing *Bound Power*. E.g. when the summoned unit dies it will put 90% of it's *Bound Power* (45) into the *Void Power*. This pool is constantly flowing back to the player as *Free Power* at a rate which is increased with the size of the pool.

This 90% is not a constant and an overview of how much power is returned to the void can be found in [this](https://skylords-reborn.fandom.com/wiki/Power?file=Powertable.png) overview on the Skylords Reborn wiki.

Spawning units or casting spells will return 90% of the spent power to the void, but crucially a Power Well or Momument will not return any power! And this is the central mechanic where PvP evolves around.

---image of power flow---

Power wells have paid off by delivering their cost of 100 power after 200 seconds, which means destroying it before this time causes a permanent power loss for the opponent. Killing enemy squads only means a permanent power loss of 10% of the unit's cost. Similarly, desotrying a Monument is also a huge loss of power in addition to the affected player losing access to higher-level cards.

A lot of strategies are created by this mechanic, like spending the 100 power used by your opponent on a power well on units and trying to overwhelm him or building an Orb to gain and advantage through stronger units. There are, of course, many other contributing factors such as matchups and map layout, but the central goal of Battleforge's PvP is always around finding a power advantage to win a game.

## Bot Development

Compared to classic RTS games like Age of Empires or Starcraft there is no strong focus on an economy but more on combat as only Power Wells and Monuments can be built at predefined locations on the map.
Nevertheless, the nature of RTS games makes it challenging for bot development as the action space is relatively large.

The bot was written over the course of multiple months as part of a community programming contest where multiple people developed bots for the Game and let them play against each other. 

When starting the project I was considering multiple strategies on how to generally apprach the problem:
- **Machine Learning**: for some kind of supervised learning there was no labeled data available. Reinforcement Learning would've been a possibility, but the process of letting the bot play, especially letting two bots play against each other, was not automated enough. E.g. the games would have need to be simulated in real time, which would substantially slow down the training process.
- **Behavior Trees**: this option seemed really attractive to me initally and I've spent some time understanding Behavior Trees and looking into potential libaries. They seem to be a good choice for NPC/bot behavior and are widely used in the gaming industry and game engines. However, it was hard for me to translate my developed strategy into Behavior Trees and the framework I tried also wasn't working particularly well for me, which ultimately led to abandon their usage.
- **Finite State Machines**: the most simple approach out of the three but the one that worked the best for me due to it's simplicity and their fit on how I imagined the strategy to work. I ended up using state machines and haven't regretted the choice so far.

## Technical setup
Battleforge uses a client-server architecture with a (more or less) authorative server. Clients send a list of commands to the server (e.g. walk a unit to position x or attack entity y), which are either accepted or rejected by the server.

The bot works through exposing a local HTTP server which is called by the game client with a POST request each tick (1 tick=100 ms) to provide the bot with the current game state. The bot then also responds with a list of the commands it wants to execute. The Game client works like a relay in this case between the bot and the game server.

The Skylords Reborn team provided an API available in different programming languages which already takes care of parsing the serialized game state sent by the game client and providing functionality e.g. for sending commands. I chose Rust for development simply because I wanted to learn it and this seemed like a good fit.

One of the first things I did was to write a singleton `GameInfo` struct which parses the game state and collects higher-level information from it, like a list of squads, power wells or locations (power well/orb clusters). I also use it to parse card data from a large json file to figure out counter units, for example. It is initialized once and passed to almost every function, as it contains all the data about the current state.

I'm using a hierarchy of Finite State Machines, which I call *Controllers*. Each Controller has a fixed amount of possible states and almost each of them (the only exception being the `SpawnController`) has a `tick` function which is called each Tick and returns a list of commands it wants to send to the server. Controllers execute the `tick` function of their subsidiary children, while passing commands returned by them to their superior Controller.

There are currently four controller
- `SquadController`: manages a single squad/unit from spawning it to moving or attacking. It is the lowest level Controller.
- `CombatController`: reponsible for a group of `SquadControllers`. In Battleforge it is common to attack with a group of units, so this Controller manages multiple squads in an attack of a location. At the moment there is only one, but in the future this could be come multiple when I implement split attacks.
- `SpawnController`: this one is a bit special as it is only responsible for spawning new squads. For example, when attacking a location the maximum amount of units should be utilized to win the battle while at the beginning of the match a single unit is sufficient to get ground presence. Additionally, Battleforge has a system of counters based on unit sizes (e.g. a unit with `m` damaged deals bonus damaged vs a unit of size `m`) so units should be selected considering these counters.
- `MacroController`: the one controller to rule them all. It is by far the most complex one and is responsible for the overall strategy of the bot. States of it are `AttackLoc`, `Defend`, `GroundPresenceNextLoc` or `TakeWell`, for example. It implements the strategy through controlling the `CombatController` and `SpawnController`.

---image of controller hierarchy---

## Strategy
I wanted to implement the bot's strategy based on how a human would play the game. As I would consider myself having pretty good knowledge of how PvP in Battleforge works, but never gaining enough practive to efficiently convert this knowledge into meaningful successes, I thought it would be a good idea to use the bot for this purpose.

This proved to be quite challenging, as there are a lot of variables to consider when making decisions, e.g. the current location of wells, orbs and squads, the power available and the matchup, aka which cards are available to my opponent and myself.

While playing against other bots I also noticed that some of them were focussing on a single strategy, like spamming a certain unit and attacking a fixed location over and over again.
This turned out to be a big problem for my bot, because these bots were specialized and optimized for this particular task while my bot is more a mediocre generalist.
Rushing the start location or barricading with walls was an efficient strategy against my bot until I started to inlcude countermeasures.

I was a bit disappointed by this development, because it meant that I had to focus more on countering inidividual strategies instead of improving my general approach in order to stay competitive with the other bots.

My general strategy evolves around an artifical quantity, which I called `Tempo`.
If you haven't done so already, I highly suggest to read the section about [Power Economy](#power-economy).
```
Tempo = FreePower + Bound Power - Void Power
```
Tempo is a measure for how much power is available for usage, or how liquid the current power situation is.
Void Power is only slowly returning to the player as Free Power, during which this power is not available, leading to a Tempo disadvantage.
For example, spending 50 power to spawn a unit does not change your Tempo, but building a Power Well for 100 power does reduce it by this amount as Power Wells do not bind power.

In general, the bot will make and offensive move if it is at a Tempo disadvantage and defend if it is at a disadvantage.

The bots only compete on the map [Elyon](https://skylords-reborn.fandom.com/wiki/Elyon), for which I hard-coded a priority list of locations based on if the bot has a Tempo lead or not. For example, when being at an advantage, the bot will prioritize locations in the center of the map to get map control, while it will focus on easier to defend locations near it's starting location when being at a disadvantage.